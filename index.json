[
{
	"uri": "http://lunafromthemoon.github.io/RenJS/actions/showandhide/",
	"title": "Show and Hide",
	"tags": [],
	"description": "",
	"content": " The show action let\u0026rsquo;s you show game objects like backgrounds, characters and cgs. The hide action does the contrary, and allows you to hide them.\nBackgrounds Show - show background_id: [WITH transition_id]  The backgrounds will always be behind characters and cgs.\nHide - hide background_id: [WITH transition_id]  If no transition is specified, default transition is FADE (can be changed). Check what other transitions are available.\nCharacters Show - show character_id: [look_id] [WITH transition_id] [AT position] [flipped: true|false]  The characters will always be on top of the backgrounds and behind cgs. If no look is specified, default look is \u0026ldquo;normal\u0026rdquo;. If no position is specified, default position is CENTER. A position can be a coordinate like 400,600 or one of the pre defined positions. The anchor of a character is the center bottom of the sprite (usually the feet), so center position will be center bottom of the screen. Other pre defined positions are:\n CENTER: Center bottom of the screen. LEFT: 1\u0026frasl;6 of the screen width, bottom. OUTLEFT: -1\u0026frasl;6 of the screen width, bottom. Outside of the screen. RIGHT: 5\u0026frasl;6 of the screen width, bottom. OUTRIGHT: 7\u0026frasl;6 of the screen width, bottom. Outside of the screen.  Hide - hide character_id: [WITH transition_id]  If no transition is specified, default transition is CUT (can be changed). Check what other transitions are available.\nShow CGS Show - show cgs_id: [WITH transition_id] [AT position] [zoom: number] [position: coordinate] [angle: number]  The cgs will always be on top of characters and cgs.\nHide - hide cgs_id: [WITH transition_id]  If no transition is specified, default transition is FADE (can be changed). Check what other transitions are available.\nExamples - show bedroom_lamp_off: - show deuzi: AT CENTER WITH FADE - show bedroom_lamp_on: WITH FUSION - show jair: AT OUTLEFT - show jair: AT LEFT WITH MOVE - hide deuzi: WITH FADE  "
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/quickstart/",
	"title": "Quickstart",
	"tags": [],
	"description": "",
	"content": " Developer Guide Make your own game If you\u0026rsquo;re reading this, you\u0026rsquo;re probably thinking about developing a Visual Novel. It doesn\u0026rsquo;t matter if you\u0026rsquo;ve never made a game before, in this guide you\u0026rsquo;ll find how to do it from scratch. You\u0026rsquo;ve probably heard about other game engines, like Unity or Game Maker. Those tools provide a whole environment for developing many kinds of games. RenJS is a bit different. First, RenJS is specially tailored to make games of the Visual Novel genre. You can use it for other kinds of games, but for that you\u0026rsquo;ll need to extend the engine itself. If don\u0026rsquo;t know programming though, you can still write classic VNs easily. The second difference is that RenJS refers only to the code that will be the core of your game. This means, unlike Unity or Game Maker, RenJS doesn\u0026rsquo;t provide a development environment. There\u0026rsquo;s no \u0026ldquo;program\u0026rdquo; you have to install or open to make your game. RenJS is just a bunch of files that know how to read a story and show it in a web browser. To write the story you only need a text processor, even something as simple as Gedit or Notepad.\nThe quickstart is a package with all the necesary files to start creating a game. Besides the RenJS library and it\u0026rsquo;s dependencies, it comes also with a basic GUI (the one used in the tutorial game), one background, one character, and one small \u0026ldquo;hello world\u0026rdquo; scene.\nOnce you download the quickstart, you can play it by opening the \u0026ldquo;index.html\u0026rdquo; file with a web browser (Firefox recommended).\nThere\u0026rsquo;s no text or image processor mandatory for the development, but my recomendations, and the ones I use for developing myself, are Sublime Text and Gimp. They are both free, lightweight and multiplatform.\nIn the next section, we\u0026rsquo;ll see the file structure that makes up the quickstart and which are the files that contain your story.\n"
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/actions/sayandtext/",
	"title": "Say and Text",
	"tags": [],
	"description": "",
	"content": " These actions let you show text inside the text box. The difference between them is that the say action will also display the name of the character inside the name box, in the colour of the propery speechText defined for that character.\nText - text: text  Say - character_id says: text  The text will be shown letter by letter inside the text box and after it is displayed whole, the ctc (click to continue) will be shown. After this the game will wait until the player clicks anywhere on the screen to continue with the next action.\nExamples - text: It's the first day of school and you're wondering who's that girl that's been looking at you all morning - deuzi says: Welcome {name}! - deuzi says: How are you today? - text: How does she know your name?  "
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/actions/",
	"title": "Actions Guide",
	"tags": [],
	"description": "",
	"content": " Actions Guide How to write the story The story script is not that hard, you just need to learn how to format a few actions that will allow you to write the story you want to tell. There should be an action for anything you want to do in your story. For example, \u0026ldquo;play\u0026rdquo; is an action that will play music, \u0026ldquo;show\u0026rdquo; is an action that will show an image. One importan thing to remember is indentation, at level 0 there will be the names of the scenes, preceded by all of its actions, indented by two spaces.\nEvery kind of action has it\u0026rsquo;s own format, but usually it\u0026rsquo;s something like this:\naction actor: extra parameters  The \u0026ldquo;action\u0026rdquo; will be the name of the action, the \u0026ldquo;actor\u0026rdquo; the object over whom it will do the action, and the extra parameters can be anything. For example, the actions show, hide and play all follow this format. There are some exceptions, like the actions text, that doesn\u0026rsquo;t require an actor, or say, that is inverted as \u0026ldquo;actor says\u0026rdquo; to be written more naturally.\nCheatsheet Show and hide - show [BACKGROUND|CHARACTER|CGS]: [WITH TRANSITION] [AT POSITION] - hide [BACKGROUND|CHARACTER|CGS]: [WITH TRANSITION]  Transitions: CUT, FADE, FUSION, MOVE, FADETOBLACK, FADETOWHITE Positions: OUTLEFT, LEFT, CENTER, RIGHT, OUTRIGHT\nSay and text - CHARACTER says: TEXT - text: TEXT  Play and stop - play [MUSIC|SFX]: [WITH TRANSITION] - stop [MUSIC|SFX]: [WITH TRANSITION]  Choice and interrupt - choice: - OPTION1: - ACTIONS FOR OPTION1 - OPTION2: - ACTIONS FOR OPTION2 - interrupt NUMBER: - OPTION1: - ACTIONS FOR OPTION1 - OPTION2: - ACTIONS FOR OPTION2  Variables - var NAME: [TEXT|NUMBER|BOOLEAN] - text: foo {NAME} bar  If - if (CONDITION): - ACTIONS FOR CONDITION TRUE [ - else: - ACTIONS FOR CONDITION FALSE ]  Scene SCENE1: - ACTIONS FOR SCENE 1 - scene: SCENE2 SCENE2: - ACTIONS FOR SCENE 2  Wait for time or click - wait: [NUMBER|click]  Animate - animate CGS: time: NUMBER [alpha: NUMBER] [zoom: NUMBER] [position: COORDINATE] [angle: NUMBER]  Call - call FUNCTION: [PARAM1: VALUE1] [PARAM2: VALUE2]  Effects and ambients - ambient AMBIENT: [PARAM1: VALUE1] [PARAM2: VALUE2] - effect EFFECT: [PARAM1: VALUE1] [PARAM2: VALUE2]  Ambients: RAIN, SAKURA, SNOW, DRUGS, BADTRIP, CLEAR\nEffects: SHAKE, SOUND, ROLLINGCREDITS, SHOWTITLE, THUNDER, EXPLOSION\n"
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/actions/playandstop/",
	"title": "Play and Stop",
	"tags": [],
	"description": "",
	"content": " These actions allow you to play and stop background music. Play can be used to play sound effects too. Background music will be looped by default, while sound effects will play only once.\nPlay - play music_id|sfc_id: [WITH transition_id] [looped: true|false]  Stop - stop music_id|sfc_id: [WITH transition_id]  If no transition is specified, default transition is FADE (can be changed). The only other transition available is CUT.\nExamples - play morningBGM: WITH FADE - play ringtone: - stop morningBGM:  "
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/setup/",
	"title": "Setup",
	"tags": [],
	"description": "",
	"content": " Story Setup How to setup the story The story setup is a way to declare every game object your story needs, and how it will look or sound. This basically means, we will be writing what image or resource is associated with each key name used in the story. The key names are what you use in the story script to call the game objects, so you don\u0026rsquo;t have to reference the files directly in the story. If you later change the images, the story text will still be the same.\n"
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/actions/choiceandinterrupt/",
	"title": "Choice and Interrupt",
	"tags": [],
	"description": "",
	"content": " The choice action allows you to show a menu of text options. The story will then pause and wait for the player to make a decision.\nEach option has a list of further actions to be executed if it\u0026rsquo;s chosen. After executing those actions, the story will continue with the actions right after the choice action. These ations can be any of the available story actions, including another choice or a scene change. If the scene is changed, the actions after the choice will not be executed, but the scene will change immediately.\nChoice - choice: - option1: - action1 - action2 ... - option2: - action3 - action4 ... - optionN: - actionN - actionN1 ... - actionAfterChoice1 - actionAfterChoice2  Interrupt - interrupt number: - option1: - action1 - action2 ... - option2: - action3 - action4 ... - optionN: - actionN - actionN1 ... - actionAfterInterrupt1 - actionAfterInterrupt2  The interrupt action is very similar to the choice action, but the story will not wait for the player to choose, and instead will continue with the actions after the interrupt while showing the options. The number specified referes to the amount of actions the menu will stay shown. So, if you have an interrupt 5, the menu will be shown for the 5 next actions, in which the player can use them. If the player doesn\u0026rsquo;t choose any option, then they will be hidden.\nConditional options - choice: - option1: - action1 - action2 ... - option2 !if (condition1): - action3 - action4 ... - optionN !if (conditionN): - actionN - actionN1 ... - actionAfterChoice1 - actionAfterChoice2  Sometimes you need to show an option only if a condition is met. In these cases, the conditional option can be used for either choices or interrupts. If the condition is not satisfied, that option will not be shown. Check more about how to make conditions.\nExamples - choice: - Choose Deuzilene: - marco says: Good choice - var partner: \u0026quot;deuzi\u0026quot; - Choose Jair: - marco says: You really like a challenge, right? - var partner: \u0026quot;jair\u0026quot; - Choose no one !if ({readBook}): - show marco: surprise - marco says: No one has ever completed this task alone before! - var partner: \u0026quot;no one\u0026quot; - show marco: normal - marco: So you've chosen {partner}, are you happy with it?  "
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/gui/",
	"title": "GUI",
	"tags": [],
	"description": "",
	"content": " GUI How to personalize the GUI Before thinking about characters, backgrounds and music, we need to setup the look and feel of the game, that is, user interface. The user interface is just as important for the story, since it sets the mood for the player even before she starts playing it. There are many resources about how to choose the best interface for your game. There\u0026rsquo;s also a rich community of visual novel developers who create and distribute their own art and designs, sometimes as free creative commons resources.\nRenJS allows you to set up a really simple user interface, that you can visually alter easily from the gui configuration file (GUI.yaml). It might be hard at first, especially if you\u0026rsquo;re not a graphical designer, to figure out how to make changes to the GUI, but this system allows for a very flexible user interface that will enrich the story you want to tell.\n"
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/engine/transitions/",
	"title": "Adding New Transitions",
	"tags": [],
	"description": "",
	"content": " The transitions are used everytime we show, hide or change an image. This affects how that will be achieved. There are a few usual transitions ready to use with the game: CUT, FADE, FUSION, MOVE. This are usually enought in a very classical game, but you don\u0026rsquo;t have to be limited to them. Creating transitions is really easy if you know some javascript.\nAll of the code concerning the transitions is inside the file RenJS/Transitions.js, by reading how each of the current transitions is made, you\u0026rsquo;ll learn what you need to do to create your own.\nThe transitions file contains a map called RenJS.transitions, this means we are assigning all of their contents to a map called transitions inside the global object RenJS.\nEach of the key-value contents of this map is a transition. The key is the name, and the value is a function that will transform one image to the other. In this case, the name is \u0026lsquo;CUT\u0026rsquo;, and that\u0026rsquo;s the name you call from your story when showing or hiding images. The parameters received are:\n from: The old image. It could be a null object if, for example, a new characters appears on screen. to: The new image. It could be a null object if, for example, a character dissapears from the screen. position: The new position of the image (x and y). This is important for character or object transitions, that could move from one place to another, but not so much for backgrounds. scaleX: This is the scale of the image, but usually it\u0026rsquo;s meant to indicate if it\u0026rsquo;s flipped (value is -1) or not (value is 1).  CUT Let\u0026rsquo;s see the first element in this map, the most simple transition: CUT. This transition simply hides the old image and shows the new one.\nCUT: function(from,to,position,scaleX){ if (from){ from.alpha = 0; } if (to) { to.alpha = 1; setNewProperties(to,position,scaleX); } RenJS.resolve(); },  Normally, in a game, when you show an image, you create the sprite object, that will be added to the screen and shown. When you want to hide that image, you destroy the sprite object.\nIn RenJS, we will use the same sprites many times, so when the game starts, all of the sprites are created and hidden by making them transparent (property alpha 0). So when you want to show them, you simply make them solid again (property alpha 1), and when you want to hide them, you make them transparent again (property alpha 0).\nTaking this into account, we can see how the CUT function works:\n If we have a from image, we change its alpha to 0 If we have a to image, we change its alpha to 1, and then call the function setNewProperties, that will transfer position and scale to the new sprite We tell the engine we\u0026rsquo;re ready to continue with the story  The last line, RenJS.resolve() is really important. We need to let the engine know when we\u0026rsquo;re ready to continue. In this case it\u0026rsquo;s straightforward: the function finishes and we can continue; but we will see next how that is not always the case.\nFADE In a FADE transition the old image fades out (it gradually becomes transparent), and the new image fades in (it gradually becomes solid). To achieve this we need to tween the alpha property. Tweening, in digital animations, refers to interpolating properties of an image through time, to animate them. To make the process easier, RenJS has a Tween manager that allows you to tween an image normally or perform chained or parallel tweens.\nFor the FADE transition we use two additional transitions, that can not be called from the story: FADEOUT and FADEIN. They will be called authomatically when the FADE transition receives only one the images. If it only has a from image it will do a FADEOUT, if there\u0026rsquo;s only a to image it will do a FADEIN.\nFADEOUT and FADEIN are really simple. They simply tween the image and tell the engine to continue.\nFADEOUT: function(from){ RenJS.tweenManager.tween(from,{ alpha: 0 },RenJS.resolve,config.fadetime,true); }, FADEIN: function(to,position,scaleX){ setNewProperties(to,position,scaleX); RenJS.tweenManager.tween(to,{ alpha: 1 },RenJS.resolve,config.fadetime,true); },  With the tweenManager, we can call the function tween that takes:\n An image to tween A map of properties to tween (from the current value of the image) A callback function (what to do after the tween is finished) An interpolation time If the tween should start running immediately A time delay  In FADEOUT we send the from image, that we want to hide. The property is then the alpha of the image, and the value we want to get to is 0. As the current value of the image alpha is 1, the tween will interpolate the alpha from 1 to 0. The callback is the resolve function, since we don\u0026rsquo;t want to do anything else after the image is hidden. The fadetime is the value determined by the Defaults.js file as \u0026ldquo;fadetime\u0026rdquo;. And we also need to send a true as a start parameter, we want it to start right away. As we don\u0026rsquo;t need any delay, we can skip that parameter.\nThe FADEIN transition is similar, but we do the opposite, we need to show the image. Also, we need to pass the new position and scaleX properties to the image, so the first thing we do is call setNewProperties, and then we do the tween. The only change from the FADEOUT case is that we now want to tween to alpha 1, intead of 0, to show it.\nFADE: function(from,to,position,scaleX){ if (!from){ RenJS.transitions.FADEIN(to,position,scaleX); return; } if (!to){ RenJS.transitions.FADEOUT(from); return; } RenJS.tweenManager.chain([ {sprite:from,tweenables:{alpha:0},callback:function(){ setNewProperties(to,position,scaleX); }}, {sprite:to,tweenables:{alpha:1},callback:RenJS.resolve} ],config.fadetime); },  When we have both images, we need to do something a bit different: We need to chain both tweens, the one that will hide the old image and the one that will show the new one.\nFor that we call the chain function of the tweenManager. We need to send two things:\n A list of tweens to chain A global time of execution  The list of tweens contains elements with: * sprite: The image * tweenables: The properties for tweening * callback: The callback function * time: The interpolation time (if skipped, the time will be the global time will be divided by the amount of elements on this list) * delay: The delay to start this tween after the previous one\nSo, basically, the same information a normal tween takes, but repeated for every tween in the chain. In our case, the first tween is hiding the old image, and its callback if a function that will set the properties of the new image before showing it. The second tween is showing the new image.\nMOVE MOVE: function(from,to,position,scaleX){ if (!from || !to){ RenJS.transitions.CUT(from,to,position); return; } RenJS.tweenManager.tween(from,{ x:position.x,y:position.y },function(){ setNewProperties(to,position,scaleX); from.alpha = 0; to.alpha = 1; RenJS.resolve(); },config.fadetime,true); },  The move transition will tween not the alpha, but the position of an image. In this case, if we don\u0026rsquo;t have both images, the equivalence will be with a CUT transition of showing or hiding the image. If we do have them, we need to tween the first image\u0026rsquo;s position, that is, the x and y properties, to the new properties. To finish, we need to set the new properites to the new image, and do a CUT transition. In most cases, the from and to image in this case is the same one, so this last part won\u0026rsquo;t do very much. Finally, the resolve function is called so the game can continue.\nThere are some more transitions that you can check in the file, but changing properties and tweening is what you should know about the transitions, so you can make your own.\nWhen you add a new transition, you will call it from the story like you do with the others:\nMYTRANSITION: function(from,to,position,scaleX){ //your transition's code RenJS.resolve(); },  - show char1: WITH MYTRANSITION  "
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/mobileanddesktop/electron/",
	"title": "Electron",
	"tags": [],
	"description": "",
	"content": " One way to port the game to a native desktop application easily is by using Electron. Electron is a framework for creating native applications with web technologies like JavaScript, HTML, and CSS. If you don\u0026rsquo;t know anything about it, don\u0026rsquo;t worry too much, here you can find the RenJS Quickstart ported to it.\nThe way to write your game will be the same, since the Engine doesn\u0026rsquo;t actually change, we only add Electron as a wrapper over it. The way electron works, it creates a native windows for the target platform and calls a web page to load it on it. That page will be the one we use to show the game.\nThe only difference in the code lays in the config.js file, with this little part at the end of it:\nif (typeof module !== 'undefined' \u0026amp;\u0026amp; module.exports) { module.exports = globalConfig; }  This is a way for Electron to find this configuration, so it can get the right windows size for loading the game. Another difference you may notice is in the index.html file. We add a style to make the game fit the window without any extra margins. As always, your own game should be in the story folder, the assets in the assets folder and the engine in the RenJS folder. If you made any change to it (adding new functions, changing default values, etc), you should copy not only your story and assets over the Quickstart, but also your modified version of RenJS.\nPackage the game Now to the \u0026ldquo;hard\u0026rdquo; part: The terminal.\nTo run and package the game as a desktop application, you\u0026rsquo;ll need to use the terminal. If you\u0026rsquo;ve never used it before, it may seem a bit scary, but it\u0026rsquo;s really easy. To begin with, we need to install the dependencies for running and packaging Electron, these are:\n node npm electron-packager  Node and npm usually come together, when you install one, the other one is installed too. Node is the engine behind Electron that lets it run as a local server on a computer. This is how we \u0026ldquo;serve\u0026rdquo; our game web page to the window Electron creates. Npm is just a package manager that lets you install libraries and dependencies easily. Once you have npm, you can use it to install electron-packager like this:\nnpm install electron-packager -g  After you have all of the requirements, we need to install the rest of the project. To do this, we will use npm. In the root of the Quickstart project we\u0026rsquo;ll find a file called package.json. This file has all the information npm needs to install and run the project.\n# Go into the repository cd RenJSQuickstartElectron # Install project npm install # Run it npm start  If you checked the package.json file, there\u0026rsquo;s a section called scripts. Here there are some scripts ready to use, the main one is start, which simply runs the game with electron. The other ones are to package the whole project as an executable for each of the platforms.\nOnce the game is finished and you\u0026rsquo;re ready to package you have to simply call the previously mentioned scripts:\n# For linux npm run package-linux # For mac npm run package-mac # For windows npm run package-win  And that\u0026rsquo;s it!\n"
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/engine/docs/",
	"title": "Engine documentation",
	"tags": [],
	"description": "",
	"content": " Page under construction If you\u0026rsquo;re a javascript developer and you\u0026rsquo;re thinking about extending RenJS, this is the place to start. In this section we\u0026rsquo;ll see how RenJS works, how to add new story actions, new functionality for the menus, etc.\nRenJS is separated into many files that each take care of a subsystem of it:\n RenJSBootstrap: The bootstrap, it creates the game instance, loads a splash screen and kicks off the preloading process for the whole game. Preload: The preloader in two stages, first it loads all of RenJS and the story/configuration files and then it loads the actual assets of the game. It also creates the GUI manager and initializes everything. SimpleGUI: A centralization of the GUI, with functions for creating it and displaying it. It also takes care of the visual aspects of showing dialogs and the buttons for player choices. RenJS: Creates the global object RenJS which contains all of the main control variables of the game. It also contains all the functions called from the GUI, like start the game, save, autoplay, etc. It initializes here all of the managers. Background Manager: It takes care of the backgrounds. How to show them, hide them, knowing the current background, etc. Character Manager: It takes care of the characters. It initialize all of the characters, allows for showing and hiding them with a particular look and position, and keeps track of the current characters being shown. Audio Manager: It takes care of the audio, both music and sfx. It can start and stop music, loop it, etc. Cgs Manager: Takes care of the cgs. How to show them, hide them, animate them and keeps tracks of all the current cgs being shown. Text Manager: Very little manager to encapsulate the calls to the gui text box. Tween Manager: Takes care of tweening all of the images, either backgrounds, characters or cgs. It adds support for sequential and parallel tweening. Logic Manager: Takes care of any logic and game branching. It helps with showing the possible choices to the player and adding the new actions to the story according to the outcome. It also takes care of setting and getting variable values used in the story and evaluating expressions. Story Manager: It takes care of the story flux, it interprets the story file line by line and calls the responsible manager for each action. Transitions: Map containing the functions to realise different image transitions, like fading an image. Effects: Map containing the functions to realise the different special effects, like flashing an image. Ambient: Map containing the functions to realise the different ambient effects, like a particle emmitter simulating rain. Defaults: Some of the default values for the game, for example, game name, text style, starting game settings like text speed, music volume, etc; the default positions like CENTER, LEFT and RIGHT, and the default transitions according to the element type. CustomContent: A map that should contain any additional functions to call with the call action.  Additionally, it needs a few libraries:\n Phaser 2.6 as a base 2D videogame engine, to show images, reproduce sounds and manage input, js-yaml (and esprima) to parse the yaml files. undercore for data manipulation  "
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/quickstart/structure/",
	"title": "File Structure",
	"tags": [],
	"description": "",
	"content": " The quickstart is composed of a few files and folders, including the \u0026ldquo;executable\u0026rdquo; file index.html. Creating a game with RenJS means creating also a web page that runs said game. This allows you to ship your game to any platform that can run a web browser: Linux, Mac, Windows and even mobile devices, without needing to change your code.\nLet\u0026rsquo;s take a look at these files:\n RenJS libs assets story index.html config.js  Index The index.html file is the web page where the game will be shown. The contents are minimal, the only thing we need to do here is to call the files that will load the game. Those files are:\n Phaser: The most important library of the engine, it takes care of the low level parts of the game like showing images, reproducing sound, etc. Config: The global configuration for the game, many important parameters for booting up are here, like screen size, the splash screen and the location of your story files. RenJSBootstrap: The bootstrap for RenJS, it sets up the splash screen and loading bar to let the player know resources are being loaded, and starts loading them.  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot; /\u0026gt; \u0026lt;title\u0026gt; RenJS \u0026lt;/title\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;libs/phaser.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;config.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;RenJS/RenJSBootstrap.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Config The config file contains very important configuration parameters for starting the game. These are the minimal requirements to create the frame in the web page and start loading its contents.\nvar globalConfig = { w:800, h:600, mode: \u0026quot;AUTO\u0026quot;, scaleMode: \u0026quot;SHOW_ALL\u0026quot;, //SHOW_ALL, EXACT_FIT splash: { //The \u0026quot;Loading\u0026quot; page for your game loadingScreen: \u0026quot;assets/gui/splash.png\u0026quot;, //splash background loadingBar: { fullBar: \u0026quot;assets/gui/loadingbar.png\u0026quot;, position: {x:111,y:462} } }, fonts: \u0026quot;assets/gui/fonts.css\u0026quot;, guiConfig: \u0026quot;story/GUI.yaml\u0026quot;, storySetup: \u0026quot;story/Setup.yaml\u0026quot;, //as many story text files as you want storyText: [ \u0026quot;story/YourStory.yaml\u0026quot; ], }  Let\u0026rsquo;s check what each of these parameters mean:\n Screen size: w and h parameters are the resolution of the game, as width and height in pixels. You can use any resolution you want, but you\u0026rsquo;ll have to make sure your GUI, backgrounds and other images matches with it. Mode: Phaser\u0026rsquo;s rendering mode, unless you need to extend RenJS, you shouldn\u0026rsquo;t touch this option. ScaleMode: It\u0026rsquo;s related to the scaling of the game. The default option is \u0026ldquo;SHOW_ALL\u0026rdquo;, that will scale the game to fit the whole screen (either in the computer or in a mobile device) but keeping the aspect ratio. Another interesting option could be \u0026ldquo;EXACT_FIT\u0026rdquo;, that would strech the game to fit the screen, not keeping the aspect ratio. Splash: It\u0026rsquo;s the image that will be shown while the game is loading. Depending on the size of the assets, it might take a while, so you can also add a loading bar, that will fill up from left to right to show the loading progress. If you show a bar, you will also need to specify where to show it, with the option \u0026ldquo;position\u0026rdquo;. Fonts: This parameter specifies where to find the fonts.css file. This file is just to load your fonts onto the web page, and make it easier for Phaser to find it and use it to show all the texts in the game. Game scripts: guiConfig, storySetup and storyText are the files that make up your story, and usually, the files that will change the most (along with the assets) from story to story. You need to always have one guiConfig and storySetup, but you can have as many storyText files as you want.  RenJS The files on the RenJS folder constitute the core of the game engine, the code that interprets your story and shows it to the players. The only one you need to take into account for now is RenJSBootstrap.js. This file is in charge of loading all the other .js files, and also every asset (images, music, etc) used by your game. If you know javascript programming and want to learn more about how it works, the Engine section has comprehensive documentation of the library.\nOther Libraries The files on the libs folder are external libraries that RenJS needs to work properly, the most importan being PhaserJS, the \u0026ldquo;parent\u0026rdquo; engine, that provides the methods for showing images, playing music, etc.\nThe Story and its Assets The assets folder contains all the resources used by your game. This includes the character images, backgrounds, music, etc, and also everything that makes up the GUI, like the menus backgrounds, buttons and everything else. This folder is not mandatory for every game, and neither is the structure followed by this quickstart. Your assets can be anywhere inside the root folder, and organized however you like.\nInside the story folder there are three .yaml files. As with the assets, you don\u0026rsquo;t really need to have them inside this or any folder, but it\u0026rsquo;s a good practice. These three files contain the story, its text and its configuration. You should have one GUI configuration file, one story setup file and as many story text files as you want. You can name these files whatever you like, and it\u0026rsquo;d be a good idea to have descriptive names for each one. The text of your story could be separated in many different files named after the sections of the game it contains, for example:\n intro.yaml path1.yaml path2.yaml endings.yaml  In the next chapter, we\u0026rsquo;ll take a look at the contents of these three files.\n"
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/gui/gui/",
	"title": "The GUI File",
	"tags": [],
	"description": "",
	"content": " The GUI file (identified in the config.js file as \u0026ldquo;guiConfig\u0026rdquo;) has three main sections:\n assets: The list of assets used to build the gui, with key and file name. hud: The head-up display, this is what the player will see during the game, and it includes the text box to show the dialogs, the name box to show the name of the character talking and any button the player can use during game like autoplay, skip or save. menus: All the different menus of the game. You should at least have one main menu to start the game, and can have as many extra menus as you want. Some examples of what extra menus you could need are a settings menu, a load game menu, a scenes menu, etc.  Assets A list of all the assets, ordered by their types: images, spritesheets (for the buttons), audio, etc. The spritesheets take two extra parameters that indicate the width and height of each of its frames.\nassets: fonts: - audimat-mono images: mainBackground: assets/gui/menu.png settingsBackground: assets/gui/settings.png sliderFull: assets/gui/slider.png messageBox: assets/gui/textbox.png nameBox: assets/gui/namebox.png ctc: assets/gui/ctc.png spritesheets: startButton: assets/gui/startbutton.png 163 83 loadButton: assets/gui/loadbutton.png 163 83 saveButton: assets/gui/savebutton.png 163 83 settingsButton: assets/gui/settingsbutton.png 163 83 returnButton: assets/gui/returnbutton.png 163 83 qmAutoButton: assets/gui/qmenuauto.png 47 45 qmSkipButton: assets/gui/qmenuskip.png 47 45 qmSettingsButton: assets/gui/qmenusettings.png 47 45 qmMuteButton: assets/gui/Mute.png 50 50 qmSaveButton: assets/gui/qmenusave.png 47 45 choice: assets/gui/choice.png 716 65 interrupt: assets/gui/interrupt.png 716 95 audio: mainMusic: assets/audio/Evan_Schaeffer_-_01_-_Aqueduct.mp3  You can call each of this assets whatever you like, but it\u0026rsquo;s a good practice to use descriptive names for each one.\nFonts The fonts are a special case, you need a list of the font names used declared in the assets section of the GUI file, like this:\nassets: fonts: - audimat-mono - old-standard - playfair  These fonts should also be declared in a css file, referenced in the config.js file (e.g. fonts.css).\n@font-face { font-family: 'audimat-mono'; src: url('assets/gui/audimat-mono.ttf'); src: url('assets/gui/audimat-mono.ttf').format('truetype'); font-weight: normal; font-style: normal; } @font-face { font-family: 'old-standard'; src: url('assets/gui/OldStandard-Regular.ttf'); src: url('assets/gui/OldStandard-Regular.ttf') format('truetype'); font-weight: normal; font-style: normal; } @font-face { font-family: 'playfair'; src: url('assets/gui/PlayfairDisplaySC-Regular.ttf'); src: url('assets/gui/PlayfairDisplaySC-Regular.ttf') format('truetype'); font-weight: normal; font-style: normal; }  This css file will be loaded onto the browser along with the game, and will allow it to find the font files (in this case only one: audimat-mono.ttf) and making them available for RenJS to use them.\nHUD The hud, as explained above, is the part of the user interface shown during the game. In a visual novel, we have a set of elements common to most of them, like:\n Text box: Where the text and dialogs of the game will be shown. If there is no text to show, this box will be hidden.  CTC: The click to continue symbol is usually an animated or blinking image that indicates the player they have to click to continue with the story.  Name box: Where the name of the talking character is displayed. If no character is talking, this box will be hidden. Quick menu: A little menu the player can use during the game, the usual options are:  Autoplay: Instead of waiting for the player to click after each dialog, the game will wait for a moment and continue until it needs the player input to make a choice. Skip: Like autoplay, but the game will be going fast. Used mostly to catch up and get quickly to the different ramifications of the game. Save: The the current state of the game, to be able to continue later. It could also open a Save Menu and let the player choose a slot for saving. Settings: Open the settings menu  Choice button: Usually when the player has to make a choice, it will be by pressing a button with the desired option text.  Interrupt button: Same as the choice button, but for an interrupting option. It can be the same as the choice, or change slightly.   A usual Hud setup looks like this:\nhud: area: - 640 450 748 554 message: position: x: 46 y: 435 textPosition: x: 36 y: 36 textStyle: font: 16pt audimat-mono wordWrap: true wordWrapWidth: 545 fill: \u0026quot;#ac9393\u0026quot; name: position: x: 36 y: -40 textStyle: font: 20pt audimat-mono boundsAlignH: center boundsAlignV: middle ctc: position: x: 570 y: 90 animated: false choice: separation: 95 textStyle: font: 20pt audimat-mono boundsAlignH: center boundsAlignV: middle fill: \u0026quot;#666666\u0026quot; interrupt: textStyle: font: 20pt audimat-mono boundsAlignH: center boundsAlignV: middle fill: \u0026quot;#664b4b\u0026quot; buttons: auto: position: x: 647 y: 502 sprite: qmAutoButton skip: position: x: 694 y: 502 sprite: qmSkipButton save: position: x: 694 y: 457 sprite: qmSaveButton settings: position: x: 647 y: 457 sprite: qmSettingsButton  The area refers to a space defined by two points in the screen (x1 y1 x2 y2) inside of which the clicks of the player don\u0026rsquo;t count as \u0026ldquo;game clicks\u0026rdquo;. So, if the game is waiting for the player to click, to continue with the story, but the player clicks inside this area, the game will not continue. We need this area to manage the interaction with the quick menu in the Hud. If the player clicks in the save button, it just means it wants to save, not continue with the story. This area doesn\u0026rsquo;t have to be exactly the size of the menu, and it can actually cover more parts of the screen. You can define as many \u0026ldquo;non clickable areas\u0026rdquo; as you like.\nThe message is the text box, or message box, definition. It takes a position in the screen to show the image (from it\u0026rsquo;s left up corner), a text position to define where to start writing the text, relative to the message position; and the text style defined by font, if it should wordwrap and the width and the text color. You can add more text style options as long as they are valid for a Phaser text object.\nThe name tag defines the namebox. It\u0026rsquo;s position should be relative to the text box, and you also need to define a text style for it.\nThe ctc is the click to continue, you just need to define a position relative to the text box, and say if it\u0026rsquo;s animated or not. If not animated (not a spritesheet) it will blink.\nThe choice is the choice button. Unless you specify a position, it will be centered in the screen. You also need to define a text style and a separation, in pixels, to show all of the choices as a list.\nIn interrupt you can only define a different text style, since it will take the same parameters defined for the choice.\nThe buttons tag refers to the quick menu. For each button you need to declare a key. This key is important, because it will be used to determine what the button will do. For example, the button save will call the save action, the button skip will call the skip action, and so on. If you have an extra button in your GUI that needs to do something different, you can add it with a specific key here, and then make sure you have a function to pair it with. The button has also a position and a sprite.\nYou proably noticed that there\u0026rsquo;s no sprites declared for message, name, etc. This is because the names of the assets are the default ones. If you change the asset name, then you would need to define also a sprite name in each of these elements.\nMenus The menus section is a list with the different available menus of the game. The only mandatory one has to be called main, and it\u0026rsquo;s the menu that will be called when the game loads. Each menu has a background (if not declared, it will take the default asset _menuname_Background), optionally music, and a list of buttons. To make it easier for making a settings menu, you can define also sliders, for things like volume or game speed.\nmenus: main: music: mainMusic buttons: start: position: x: 112 y: 462 sprite: startButton load: position: x: 320 y: 462 sprite: loadButton settings: position: x: 528 y: 462 sprite: settingsButton settings: buttons: return: position: x: 112 y: 500 sprite: returnButton start: position: x: 320 y: 500 sprite: startButton load: position: x: 528 y: 500 sprite: loadButton sliders: textSpeed: position: x: 436 y: 235 sprite: sliderFull autoSpeed: position: x: 436 y: 364 sprite: sliderFull bgmv: position: x: 147 y: 235 sprite: sliderFull sfxv: position: x: 147 y: 364 sprite: sliderFull  As with the quick menu, the actions of the buttons and properties of the slider will be defined by its key name.\nThis kind of GUI is called a simple GUI because it lets you create a very simple but highly personalized GUI. You can check in the games section some of what you can achieve with this simple system.\nIf you want, you can also replace the simple gui entirely and code your own. For that, chech the engine section to see more details on how the gui interacts with the game.\n"
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/setup/setup/",
	"title": "The Setup File",
	"tags": [],
	"description": "",
	"content": " The setup file (usually something like Setup.yaml) has many sections, that can be written down in any order, and you might not need them all.\nBackgrounds A simple list of all the backgrounds of the game, with key (the name called from the story text) and filename.\nbackgrounds: room: assets/backgrounds/room_day.jpg room_night: assets/backgrounds/room_night.jpg room_night_light: assets/backgrounds/room_night_light.jpg school_morning: assets/backgrounds/school_corridor.jpg school_afternoon: assets/backgrounds/school_corridor_afternoon.jpg  Characters The characters have some extra properties.\n displayName: The key will be used to reference the character in the story text, but the display name is the one that will be shown to the player, and it can contain spaces and special characters, it can also be changed during the game. speechColour: The colour used for showing the name in the namebox. looks: A list with key and filename for every look of the character. The key can be anything you want, but it\u0026rsquo;s better to make it as descriptive as possible, to make the story writting more easy and natural.  characters: deuzi: displayName: Deuzilene speechColour: \u0026quot;#ca90cf\u0026quot; looks: normal_school: assets/characters/Char3NormalSchool.png happy_school: assets/characters/Char3HappySchool.png angry_school: assets/characters/Char3AngrySchool.png normal_casual: assets/characters/Char3Normal.png happy_casual: assets/characters/Char3Happy.png angry_casual: assets/characters/Char3Angry.png liz: displayName: Liz speechColour: \u0026quot;#d5e6e7\u0026quot; looks: normal_school: assets/characters/Char2NormalSchool.png happy_school: assets/characters/Char2HappySchool.png angry_school: assets/characters/Char2AngrySchool.png normal_casual: assets/characters/Char2Normal.png happy_casual: assets/characters/Char2Happy.png angry_casual: assets/characters/Char2Angry.png  CGS CGS stands for computer graphics, but in RenJS it just means any extra object you need to show in the game. It will probably be renamed in the future. As with the backgrounds, the only information we need is a key name and a file name.\ncgs: phone1: assets/objects/phone1.png phone2: assets/objects/phone2.png  Music The music tracks, with a key and file name. These files can be .mp3, .ogg or other sound files. The music declared here is meant to be played in a loop, that is, as background music. If you just need a one off sound effect, you need to declare is as an sfx.\nmusic: morningBGM: assets/audio/Evan_Schaeffer_-_03_-_Glow.mp3 storeBGM: assets/audio/Evan_Schaeffer_-_18_-_Big_Tree.mp3  SFX Sound effects, meant to be played one time, declared with key and file name as always.\nsfx: ringtonePinkPhone: assets/audio/nokia6210-24-elise.mp3 ringtoneGreenPhone: assets/audio/alcatel-top_secret.mp3  Extra You can load any extra image, sound or resource you need in this section. Why would you need extra resources? For the effects and ambients, for example, or for any extra game code you add. Each extra resource has to be listed under its resource type. So, images will be under image and audio under audio.\nYou can also load spritesheets, this is a normal image that contains the frames of an animation. Currently, RenJS doesn\u0026rsquo;t have any action that suppports the use of spritesheets directly, but it\u0026rsquo;s used in some of the effect examples. Besides the key and the file name, the spritesheet needs two numbers that indicate height and width of each of the frames it contains.\nAnother thing you could load is scripts, to load for example, a piece of code needed for an effect.\nextra: image: title: assets/gui/titles.png rain: assets/ambient/rain.png thunder: assets/effects/Thunder_Effect.png audio: cicadas: assets/audio/Cicada.mp3 rain: assets/audio/Rain.mp3 thunder: assets/audio/thunder_strike_1.mp3 spritesheets: explosion: assets/effects/explosion.png 450 274 static: assets/ambient/static.png 320 256 scripts: marble: assets/ambient/Marble.js lightbeam: assets/ambient/LightBeam.js  "
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/actions/var/",
	"title": "Variables",
	"tags": [],
	"description": "",
	"content": " The var action allows you to store important values during the story. This values then can be display as text or dialogue and can be used to compare and form conditions.\nAsignation To set the value of a variable we use the var action. This kind of action is often called an asignation. An asignation is said to have two parts, left and rigth, separated by a colon. The left part has information about the variable being set, and in our case, also includes the name of the action. The right part contains the value that will be set to that variable. This value can be of three types:\n Number Boolean String  The right part can therefore be text, a number or true|false.\n- var var1: number - var var2: true|false - var var3: text  String variables String variables are text, and can be combined with other variables to make more complex sentences. To use a value on the right part you use the variable name surrounded by curly braces, i.e. {varX}.\n- var name: Spike - var score: 10 - var report: \u0026quot;Hi {name}, you have {score} points!\u0026quot;  Show variables Variables of any kind can be shown with text or say action, in the same way used to conform string variables.\n- text: {report} - spike says: \u0026quot;What? Only {score} points? I though I was doing so well.\u0026quot;  Operations The right part can also be an operation whose result is any of the above mentioned types. These operations use special symbols depending on the type, and can use constant values and other variables.\nArithmetic Operations The first kind of operations are arithmetic: addition, substraction, etc. These operations should resolve to a numberic value.\nThe symbols used for these operations are:\n + (Plus symbol): Means addition. - (Dash symbol): Means substraction. * (Asterisck symbol): Means multiplication. / (Slash symbol): Means division.  The operations also can use parenthesis () to change the solving order of the operation. As with normal arithmetic operations, multiplication and division have precedence over addition and substraction.\n- var var1: 5 - var var1: \u0026quot;{var1} + 1\u0026quot; - var var2: \u0026quot;{var1} * 6\u0026quot; - var var3: \u0026quot;({var1} - {var2})/3\u0026quot;  The right part should usually be between inverted commas. This is because the parser will sometimes freakout if if finds strange symbols. To ensure it reads the whole line as one, better to be safe and surround it by inverted commas.\n Boolean Operations Boolean operations should resolve to a true or false value.\nThe symbols used for these operations are:\n \u0026amp;\u0026amp; (AND): The operation will be true if both values between the AND are true. || (OR): The operation will be true if either value between the OR is true. ! (NOT): The operation will be true if the value next to the NOT is false.  The operations can also use parenthesis () to change the solving order. As with normal logic operations, NOT has precedence over AND, who has precedence over OR.\n- var var1: true - var var2: \u0026quot;!{var1}\u0026quot; - var var3: \u0026quot;{var1} \u0026amp;\u0026amp; {var2}\u0026quot; - var var4: \u0026quot;!({var1} || {var2})\u0026quot;  Another way of getting a boolean value is by comparing numbers and numeric variables. The symbols used for these operations are:\n \u0026gt; (Greater than): The operation will be true if the left value is greater than the right value. \u0026gt;= (Greater than or equal to): The operation will be true if the left value is greater than or equal to the right value. == (Equal): The operation will be true if both values are equal. \u0026lt;= (Less than or equal to): The operation will be true if the left value is less than or equal to the right value. \u0026lt; (Less than): The operation will be true if the left value is less than the right value.  As with the previous operations, parenthesis () are allowed.\n- var var1: 5 - var var2: 7 - var var3: \u0026quot;{var1} \u0026gt; {var2}\u0026quot; - var var4: \u0026quot;({var1}*2) \u0026gt; {var2}) \u0026amp;\u0026amp; ({var2}-2 == {var2})\u0026quot;  String variables can also be compared in this way using the equal operator.\nExamples - choice: - Choose Deuzilene: - marco says: Good choice - var partner: \u0026quot;deuzi\u0026quot; - Choose Jair: - marco says: You really like a challenge, right? - var partner: \u0026quot;jair\u0026quot; - Choose no one !if ({readBook}): - show marco: surprise - marco says: No one has ever completed this task alone before! - var partner: \u0026quot;no one\u0026quot; - show marco: normal - marco: So you've chosen {partner}, are you happy with it?  "
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/",
	"title": "RenJS",
	"tags": [],
	"description": "",
	"content": " Welcome What is RenJS RenJS is a Visual Novel engine, meaning a library to make a game of the visual novel genre that can run in a web browser. Inspired by RenPy, it lets you create VNs by writing something like a screenplay, easily and without needing to know how to program. On the other hand, RenJS is powered by PhaserJS, a powerful 2D video game engine for Javascript. If you\u0026rsquo;re a programmer, extending RenJS to add other kinds of game mechanics like hidden object, RPG features, etc, should be very easy.\nIf you haven\u0026rsquo;t played yet the RenJS tutorial, it\u0026rsquo;s a great demonstration of what you can achieve with RenJS, and how to achieve it easily.\nIf you already played it and you\u0026rsquo;re ready to start your own game, head up to the Quickstart.\nIf you\u0026rsquo;re a writer and need help with the syntax, you can find how every available script action works and see examples in the Actions Guide.\nIf you\u0026rsquo;re a designer and need to ajust how the game looks, check the GUI section to understand how you can achieve your prefered look and feel.\nIf you\u0026rsquo;re a programmer and want to extend or understand how RenJS works, the Engine section shows how the whole thing works.\n"
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/mobileanddesktop/",
	"title": "Mobile and Desktop",
	"tags": [],
	"description": "",
	"content": " Mobile and Desktop Run your games everywhere RenJS allows you to create HTML5 games, that is, games that run in a web browser. This means that any platform with a running web browser should be able to run your game. Linux, Mac, Windows and even mobile devices can do this, so by creating your game with RenJS, it\u0026rsquo;s effectively multiplatform.\nThere\u0026rsquo;s one catch, what if you don\u0026rsquo;t want it online? Distributing the source code and executing an html file locally would work, but there\u0026rsquo;s a better alternative. You can package your game as an executable for each platform, and your players would install it and play it in their favourite one like they do with other games.\nIn this section we will see a few different ways to achieve this. The RenJS Quickstart is already ported to three popular Frameworks for packaging:\n Electron: For Desktop applications only. Recommended for users with some computer knowledge. Cordova: For Mobile applications only. Recommended for users with some computer knowledge. Only exports to iOS from a Mac. Cocoon: Cloud platform for both desktop and mobile applications. Very easy to use, only upload the code, compile and download the results. Free version only allows two projects with a limit of 50mb.  "
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/multilang/multilang/",
	"title": "MultiLanguage Quickstart",
	"tags": [],
	"description": "",
	"content": "First, you will need the multilanguage version of the engine, that you can download from here. There are a few differences with the normal version of RenJS. First, it adds a new file to load in the index, LanguageChooser.js. This file, as its name indicates, will display the language choosing screen, and then call the bootstrap for the game. It\u0026rsquo;s a really small and simple file, and if you don\u0026rsquo;t like how the language choosing screen looks like, here is where you should change things.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot; /\u0026gt; \u0026lt;title\u0026gt; RenJS \u0026lt;/title\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;libs/phaser.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;config.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;RenJS/LanguageChooser.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;RenJS/RenJSBootstrap.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Next difference is in the config file:\nvar globalConfig = { w:800, h:600, mode: \u0026quot;AUTO\u0026quot;, scaleMode: \u0026quot;SHOW_ALL\u0026quot;, //SHOW_ALL, EXACT_FIT i18n: { langs: [\u0026quot;en\u0026quot;,\u0026quot;es\u0026quot;], path: \u0026quot;assets/gui/i18n/\u0026quot;, format: \u0026quot;.png\u0026quot;, w: 163, h: 83 }, splash: { //The \u0026quot;Loading\u0026quot; page for your game loadingScreen: \u0026quot;assets/gui/LANG/splash.png\u0026quot;, //splash background loadingBar: { fullBar: \u0026quot;assets/gui/LANG/loadingbar.png\u0026quot;, position: {x:111,y:462} } }, fonts: \u0026quot;assets/gui/fonts.css\u0026quot;, guiConfig: \u0026quot;story/GUI.yaml\u0026quot;, storySetup: \u0026quot;story/Setup.yaml\u0026quot;, //as many story text files as you want storyText: [ \u0026quot;story/LANG/YourStory.yaml\u0026quot; ], }  There are a few differences here. First, there\u0026rsquo;s a new tag called i18n. I18n is short for Internationalization, and it\u0026rsquo;s where all your multi language information is kept. It has:\n Langs: A list of the available languages. In this case we have en for english and es for spanish. Path: Where to find the language buttons that will be shown in the language choosing screen. It\u0026rsquo;s not a file, but a folder and should en in \u0026ldquo;/\u0026rdquo;. Format: The image format of the buttons, as a file extension. In this case \u0026ldquo;.png\u0026rdquo;. W and H: The width and height of the buttons. Each button has two states, normal and pressed, in the same file, this values help to see find where each frame lies.  But this is not the only difference, we can also see some files with the path \u0026ldquo;LANG\u0026rdquo; in it. If you check your story folder, for example, you will not find any folder called LANG. Insted this reserved word will be replaced by the language tag chosen by the player. So, if the player chooses spanish (tag es), everywhere where it says LANG will be replaced by es. This means, for example, that the element loadingScreen will be then loaded from \u0026ldquo;assets/gui/es/splash.png\u0026rdquo;. Same thing with your story files.\nIf you check now the story folder, you will find the setup and gui files as always, but the story file is now twice, once for spanish and once for english, in their respective folders:\n Setup.yaml GUI.yaml en  YourStory.yaml  es  YourStory.yaml   The same way you can change the loading bar for every language, you can do with every resource. For example, we need to change all of the menu\u0026rsquo;s buttons. This buttons are defined in the GUI.yaml file, so let\u0026rsquo;s inspect it\u0026rsquo;s contents:\nassets: fonts: - audimat-mono images: mainBackground: assets/gui/menu.png settingsBackground: assets/gui/LANG/settings.png sliderFull: assets/gui/slider.png messageBox: assets/gui/textbox.png nameBox: assets/gui/namebox.png ctc: assets/gui/ctc.png languageSign: assets/gui/LANG/language-sign.png spritesheets: startButton: assets/gui/LANG/startbutton.png 163 83 loadButton: assets/gui/LANG/loadbutton.png 163 83 saveButton: assets/gui/LANG/savebutton.png 163 83 settingsButton: assets/gui/LANG/settingsbutton.png 163 83 returnButton: assets/gui/LANG/returnbutton.png 163 83 qmAutoButton: assets/gui/qmenuauto.png 47 45 qmSkipButton: assets/gui/qmenuskip.png 47 45  You don\u0026rsquo;t need to have a separate GUI file for each language, though you may have them if you want, but you need to specify where to find the assets for the different languages, using the LANG reserved word in the path of these files. As with the story folder, you will find the new language folders under assets/gui, with all the assets that need to be changed. GUI and story is usually the most important parts of your game to translate, but there might be other places where you need to make changes, maybe a character or object with some writing on it? Maybe a background? With this technique you should be able to make these changes without changing too much code.\n"
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/quickstart/structure-story/",
	"title": "Story Structure",
	"tags": [],
	"description": "",
	"content": " Now that we know where our story is located, we\u0026rsquo;ll take a look at how it\u0026rsquo;s written down. The story .yaml files are what the writer will be, well, writing, for creating a game. So, let\u0026rsquo;s recap what the story folder should contain:\n The story script: one or more files with the text of the story. The story setup: the link between the story and the assets. For example, it will list who are the characters (the name you will be using in the script to refer to it) and how the character will look (the files with the images for this character). The user interface configuration: Everything else \u0026ldquo;outside\u0026rdquo; of the story, like the game menus, buttons, the dialog text boxes, etc.  If you don\u0026rsquo;t know the Yaml format, it\u0026rsquo;s a very simple configuration format that let\u0026rsquo;s you define properties with key and value. The key is a name, and the value could be any kind of data, including words, numbers, lists or more key-value pairs. The important thing to remember is that indentation is very important. Indentation is the amount of space we let from the start of the line. In Yaml, this space (it can be two spaces, four spaces or a tab character) determines the hierarchy of the properties. For example:\nparentProperty1: prop1: value1 prop2: value2 parentProperty2: prop1: value3 prop2: value4  The User Interface Before thinking about characters, backgrounds and music, we need to setup the look and feel of the game, that is, user interface. The user interface is just as important for the story, since it sets the mood for the player even before she starts playing it. There are many resources about how to choose the best interface for your game. There\u0026rsquo;s also a rich community of visual novel developers who create and distribute their own art and designs, sometimes as free creative commons resources.\nRenJS allows you to set up a really simple user interface, that you can visually alter easily from a gui configuration file (GUI.yaml). In the quickstart, all the user interface assets are inside the asset/gui folder, and these are the minimal assets that you will be needing for any game to work properly. The configuration file then is used to tell the game how and where in the screen all of this assets should be put.\nIt might be hard at first, especially if you\u0026rsquo;re not a graphical designer, to figure out how to make changes to the GUI, but this system allows for a very flexible user interface that will enrich the story you want to tell.\nTo learn more about how to modify the basic UI or create one completely from scratch, the GUI section has all the details about it.\nSetting Up the Story The next file is the story setup (Setup.yaml). In short, this file defines every character, background, etc, and links it with the pertinent asset. When you start writing your story you might not know every element of the story, or not have every asset. This file is not something you create wholly at the start and that\u0026rsquo;s it, but it will evolve with the story. Need a new character? Before using it in the story, you should add it in the setup file.\nThe quickstart code\u0026rsquo;s setup looks like this:\nbackgrounds: room: assets/backgrounds/room_day.jpg characters: deuzi: displayName: Deuzilene speechColour: \u0026quot;#ca90cf\u0026quot; looks: normal: assets/characters/Char3Normal.png happy: assets/characters/Char3Happy.png music: rollingCredits: assets/audio/Evan_Schaeffer_-_01_-_Aqueduct.mp3 morningBGM: assets/audio/Evan_Schaeffer_-_03_-_Glow.mp3  It\u0026rsquo;s simple, small and straightforward. First we define our backgrounds, then our characters, and optionally cgs, music and sound effects. Every kind of object is listed under its key name. For example, under \u0026ldquo;backgrounds\u0026rdquo;, indented by two spaces, we start listing all our different backgrounds. As we said before, in Yaml, indentation is very important. The indentation can be defined by either a \u0026ldquo;tab\u0026rdquo; character or two spaces, but you can not mix the two. So, if you start using tabs, you have to keep using them for the rest of the file. The most usual reason for your game to not load is bad format in one of the Yaml files. There are many online tools to check their syntax, and it\u0026rsquo;s a good practice to verify your game files if your game doesn\u0026rsquo;t load.\nFor most of the elements we only need to specify a name that will be used as a reference in the story file, and a path to an asset. So, in the story, when I want to show the image \u0026ldquo;room_day.jpg\u0026rdquo;, located in the folder assets/backgrounds/, I will simply call it by the name we define here, \u0026ldquo;room\u0026rdquo;. If I want to start playing the audio file \u0026ldquo;morning.mp3\u0026rdquo;, located in the folder \u0026ldquo;assets/audio\u0026rdquo;, I will call it by the name \u0026ldquo;morningBGM\u0026rdquo;.\nYou can use any name you want (without spaces, dashes nor symbols), but it\u0026rsquo;s a good practice to use a meaningful name. I could have a background with the name \u0026ldquo;background1\u0026rdquo;, but that wouldn\u0026rsquo;t be easy to understand when I\u0026rsquo;m writing my story. In the same vein, you can locate your asset files anywhere you want inside the game folder, but it\u0026rsquo;s better to organize them in a folder structure with meaningful names. For example, put all the audio files inside the subfolder audio.\nFor the characters we need more information. The display name will be the actual name of the character, it can have spaces, symbols, and anything you want. This name will be shown inside a little box (called the namebox in the UI) when they talk, so the player can identify when each character is talking during a dialog. The speech colour is a colour in hexadecimal format, and can be use in many ways by the UI, the most usual way is to use it as the text color for either the name or the dialogs of a character.\nFinally, one of the most important aspects of Visual novels is that the characters can show emotions. This is achieved by changing the image for the character. The same thing will be used to change different visual aspects of a character, like their clothes. All the different \u0026ldquo;looks\u0026rdquo; of a character are then listed under the \u0026ldquo;looks\u0026rdquo; keyword, with key name and the file associated to it. You can have a character without any look, for example, if you need an invisible narrator or protagonist.\nThe Story The quickstarts story is really simple, basically:\n We start playing the music \u0026ldquo;morningBGM\u0026rdquo; We show the background \u0026ldquo;room\u0026rdquo; We show some text, \u0026ldquo;Hello World\u0026rdquo; Then the character \u0026ldquo;deuzi\u0026rdquo; fades in to the center of the screen Deuzi says \u0026ldquo;Welcome to the Quickstart!\u0026rdquo; The game ends with rolling credits like a film  And how do we write our script to do all of this? Just writing each order as something the engine can understad:\nstart: - play morningBGM: - show room: WITH FADE - text: Hello World - show deuzi: happy AT CENTER WITH FADE - deuzi says: Welcome to the Quickstart! - effect ROLLINGCREDITS: endGame: true text: - RenJS developed by - lunafromthemoon - null - Inspired by Ren'Py - Powered by PhaserJS - null - null - background art and cgs by - konett - null - characters by - Shida - null - music by - Evan Schaeffer  The keyword \u0026ldquo;start\u0026rdquo; is the name of the scene. You can have as many scenes as you like and call them whatever you like, but you always need a scene called \u0026ldquo;start\u0026rdquo;, that will be the starting scene of your game. After the scene name, indented by two spaces, and sufixed by one dash, you can start listing all the actions of the scene. The actions are things that RenJS will execute one after the other. There should be an action for anything you want to do in your story. For example, \u0026ldquo;play\u0026rdquo; is an action that will play music, \u0026ldquo;show\u0026rdquo; is an action that will show an image. One importan thing to remember is indentation, at level 0 there will be the names of the scenes, preceded by all of its actions, indented by two spaces. Every kind of action has it\u0026rsquo;s own format, but usually it\u0026rsquo;s something like this:\naction actor: extra parameters  The \u0026ldquo;action\u0026rdquo; will be the name of the action, the \u0026ldquo;actor\u0026rdquo; the object over whom it will do the action, and the extra parameters can be anything. For example, the actions show, hide and play all follow this format. There are some exceptions, like the actions text, that doesn\u0026rsquo;t require an actor, or say, that is inverted as \u0026ldquo;actor says\u0026rdquo; to be written more naturally. You can find a list with all the actions, their formats and parameters in the actions section.\nAll of the actions in a given scene are a written as a sorted list, that means the order is very important for it\u0026rsquo;s execution. To let yaml know this, we have to prefix each action with a dash.\nYou\u0026rsquo;re now ready to start your own game, if you still have doubts, play the tutorial game or check the games archive!\n"
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/mobileanddesktop/cordova/",
	"title": "Cordova",
	"tags": [],
	"description": "",
	"content": "For creating native mobile application we can use Cordova. Just like Electron, Cordova is a wrapper for HTML5 applications to run as native apps in mobile devices: Android, iOS and Windows Phones.\nTo make things easier, grab the RenJS Quickstart with Cordova, and let\u0026rsquo;s see the main differences. The biggest one is that the game is now inside the folder www. Everything inside of it is the same, you write your story as always.\nTo test it in your computer, with a browswer, let\u0026rsquo;s install the project. You will need:\n node npm cordova  Node and npm usually come together, when you install one, the other one is installed too. Node is the engine behind Electron that lets it run as a local server on a computer. This is how we \u0026ldquo;serve\u0026rdquo; our game web page to the window Electron creates. Npm is just a package manager that lets you install libraries and dependencies easily. Once you have npm, you can use it to install electron-packager like this:\nnpm install -g cordova  To test it we need to install the project, add browser support, and then run it:\n# Go into the repository cd RenJSQuickstartCordova # Install it npm install # Go into your game folder cd www # Install it npm install # Go to root folder cd .. # Add browswer support cordova platform add browser cordova plugin add cordova-plugin-browsersync # Run it cordova run browser --live-reload  Once the game is finished and you\u0026rsquo;re ready to package, we need to add first whatever platform you want to target:\n# Add android platform cordova platform add android # Add ios platform cordova platform add ios # Add windows phone platform cordova platform add windows  And then build it like this:\n# Build it for android cordova build --release android  There are more steps involved in the creation of a mobile app, like signing the application for publishing and so on. Here is a good article about it. Once you have a signed app, you can then install it in a mobile device and play!\n"
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/actions/if/",
	"title": "If",
	"tags": [],
	"description": "",
	"content": " The if action allows you to branch your story. The if action contains a condition and a list of actions that will only be executed if the condition is true. Optionally, it can also have a list of actions to execute if the condition is false. Either list of actions can contain whatever action available. After the right actions are done, the story will continue with the actions after the if (or else, if present).\n- if (condition): - action1 - action2 ... [- else: - action3 - action4 ...] - actionAfterIf1 - actionAfterIf2  The condition can be any boolean variable or operation, as seen in the variables section.\nExamples - if (partner == \u0026quot;deuzi\u0026quot;): - show deuzi: happy - deuzi says: I knew it would be me! - else: - text: Deuzilene looks disappointed but tries to hide it.  "
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/multilang/",
	"title": "I18n",
	"tags": [],
	"description": "",
	"content": " Internationalization Multi Language Games RenJS now provides a way to make your game multilanguage. For this you will need your story script translated to every language you want to provide. You\u0026rsquo;ll also need an extra screen: Choosing the language. Due to the way the game is loaded, the player will have to choose the language at the start of the game, before the main menu is loaded. She cannot change the language in the middle of the game, but it\u0026rsquo;s possible to do it by reloading the game. The save and load features will still work between languages, so it\u0026rsquo;s of no concern for you what the player chooses and when.\nSo, let\u0026rsquo;s check what we need to do for converting our Quickstart game into a multilanguage game.\n"
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/mobileanddesktop/cocoon/",
	"title": "Cocoon",
	"tags": [],
	"description": "",
	"content": "The easiest way to package your game is by using Cocoon. Cocoon is a cloud service, that means you don\u0026rsquo;t really need to install or do anything on your own computer, everything will be done on their servers. You just need to get an account in the Cocoon Platform, upload your code (based on this RenJS Quickstart with Cocoon), press a button to compile, and press another to download the packaged results. Very easy!\nBut there\u0026rsquo;s a catch: As almost every cloud service out there, if you really want to use it, you need to pay. There\u0026rsquo;s a free version, of course, but limited to two projects of less than 50mb each. Unless your game is really small, you\u0026rsquo;ll reach this limit really quickly. The RenJS Quickstart, as small as it is, weights around 25mb already.\nLet\u0026rsquo;s check the differences with the RenJS Quickstart. The most noticeable one is now the game code is inside the folder www. As with Cordova (as Cocoon uses Cordova internally), we are adding a wrapper to the game that will allow it to execute into a webview in a mobile phone, a desktop window, etc.\nAnother difference is in the index: We add a style to the body, so it won\u0026rsquo;t have any extra margins and the game adapts perfectly to the screen; and we add an event listener that tells us when the device is ready and we can start executing the game. That\u0026rsquo;s it, the rest of the game code is exactly the same.\nThe wrapper contains a config.xml file with information like the App name, description, etc. You don\u0026rsquo;t really need to change anything in this file, since you can do it more easily from the Cocoon platform. There\u0026rsquo;s also a folder called res, containing the icons to use for each platform, that is, the icon you will use to open the game App.\nTo package the game you need to upload the code to Cocoon.io. If you still haven\u0026rsquo;t got an account there, go and make one. Once you\u0026rsquo;re logged in you\u0026rsquo;ll find a Create project section, that will allow you to upload a zip file, that should contain all your code.\nAfter it\u0026rsquo;s uploaded, there are some important settings to check before compiling:\n In settings/default: The webview engine has to be Webview. Orientation should probably be landscape, unless your game is taller than longer. Choose the targets: In the list there\u0026rsquo;s a checkbox to choose what target you want to compile your game to. Android, iOS, Windows 10 (for both mobile and desktop), X OS or Ubuntu. Signing: In the signing section you should set your keystores for the chosen targets (except Ubuntu).  After setting up everything, you have to compile it. To do this, you just need to press the Compile button, at the header of the project page. This process may take a while depending on what and how many targets you chose. You will receive an email when it\u0026rsquo;s ready, and you\u0026rsquo;ll be able to download the package for each target from the same project page.\nThat\u0026rsquo;s it! Install and play!\n"
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/actions/scene/",
	"title": "Scene",
	"tags": [],
	"description": "",
	"content": " The scene action is used to change from one scene to the other. Every scene in the story has a name and a list of actions that conform it. The scenes are not numbered, so to change from one to the other, an explicit call should be made. If no scene is called before the end of the scene, the game will return to the main menu.\nscene1: - action1 - action2 - action3 ... - scene: scene2 scene2: - action4 - action5 ...  Examples start: - show marco: WITH FADE - marco says: Good morning student, are you ready to choose your partner? - choice: - Yes: - scene: choosePartner - No: marco says: What's the problem? choosePartner: - marco says: We should go to the teachers room - show teachersRoom:  "
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/engine/",
	"title": "Extending RenJS",
	"tags": [],
	"description": "",
	"content": " Extending RenJS Add your own code Extending RenJS is not that hard. As it\u0026rsquo;s based on PhaserJS creating new functionality is really easy. There\u0026rsquo;s a lot of documentation about Phaser, and there\u0026rsquo;s also a great examples gallery that can help you achieve whatever you want.\nTo make it easier, here you\u0026rsquo;ll find the most common ways to extend a RenJS game:\n Adding new transitions: FADE, CUT and MOVE are the most usual transitions for characters and background, but what if you want to do something else? You can add your own transition and use it just as the other ones. Adding new effects and ambients: The effects and ambients shipped with RenJS are just examples used in other games created with it, but this should not limit what you can do. You can have any kind of effect, any kind of ambient you can imagine, and just as with transitions, use them in your story in a normal way. Adding new general functions: With RenJS you can create more than just classical Visual Novels. You can add your own code and extend RenJS to add new game mechanics: RPG elements, fight scenes, hidden image puzzles, whatever you want! Extending the GUI: The simple GUI used by RenJS is that, simple. But you can do many things with a GUI, adding new buttons and information display to the HUD, add a save and load menu, or an CGSs gallery.  If you want to do even more, you can find here some documentation of the engine architecture, that should help you understand the flow of the game and add the code exactly where you need to.\n"
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/actions/wait/",
	"title": "Wait time or click",
	"tags": [],
	"description": "",
	"content": " The wait action allows you to force the player to wait for some time or until they click anywhere on the screen.\n- wait: number|click  Examples - deuzi says: Ok, tell me when you're ready! - wait: click - deuzi says: Let's go then!!!  "
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/games/",
	"title": "Games",
	"tags": [],
	"description": "",
	"content": " Games made with RenJS Add yours: send me a link to lunafromthemoon@renjs.com The Tutorial RenJS tutorial, learn how to make a game easily with RenJS.\n\nCreated by lunafromthemoon.\nLa Maupin to the Rescue! Rescue your beloved girlfriend from the evil convent. Fight drunks, sneak around, fool people, set things on fire!\n\nCreated by rumpel.\n"
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/actions/animate/",
	"title": "Animate",
	"tags": [],
	"description": "",
	"content": " The animate action allows you to animate cgs. The animation can be a tween of the sprite properties, or a spritesheet animation (coming soon). A time should be specified in milliseconds, that will be how long the tween will take to complete.\nThe properties we can animate through time are:\n Alpha: The transparency of the image. It goes from 0 (completely transparent) to 1 (completely solid). Zoom: The scale of the image, as a proportion of the original size. For example, 1 is the same as the original, 0.5 is half of it, and 2 is twice it\u0026rsquo;s original size. Position: Where is the image located in the screen, as a coordinate given as x y. The x and y numbers are relative to the screen size, and they can be outside of it too. Angle: The rotation of the image, in degrees. The original image has a 0 degrees rotation.  - animate cgs_id: time: number [alpha: number] [zoom: number] [position: coordinate] [angle: number]  Examples - show phone1: AT 100 100 - animate phone1: time: 1000 position: 50 50  "
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/actions/call/",
	"title": "Call",
	"tags": [],
	"description": "",
	"content": " The call action allows you to call your very own javascript functions.\n- call function_name: param1: value1 param2: value2 ...  The function must be located in the file RenJS/CustomContent.js, inside the map customContent defined there.\nRenJS.customContent = { //put here your own functions function_name: function (params) { console.log(params.param1); console.log(params.param2); RenJS.resolve(); } }  You can do anything inside this function. The most important thing to remember is to call RenJS.resolve() after all your processing is finished. This usually means it should be at the end of the function, but it could be in a callback for an asynchronous method. The RenJS.resolve() function tells the automat that it can continue with the story and execute the next action after the call.\nInteresting resources RenJS provides all of the information and state of the game for you to use in your own function, some of the most important things to check are:\n RenJS.waitForClick(callback): This function will make the game wait until the player clicks anywhere on the screen. If callback is not defined, the action executed after the click will be RenJS.resolve(). Similar to this function there\u0026rsquo;s also waitTimeout(time,callback) and waitForClickOrTimeout(time,callback). RenJS.logicManager.vars: This is the map of all the story variables set during the game with the action var. RenJS.bgManager.current: The current background sprite. RenJS.bgManager.backgrounds contains all of the backgrounds. RenJS.bgManager.showing: A map with all the characters currently on screen with look, position and if it\u0026rsquo;s flipped. RenJS.bgManager.characters contains all of the characters, with name, speechColour and looks (as a map of Sprites). RenJS.cgsManager.current: A map with all the cgs currently on screen. RenJS.bgManager.cgs contains all of the cgs sprites. RenJS.save(slot) and RenJS.load(slot): Saves and load on a specific slot. RenJS.setBlackOverlay() and RenJS.removeBlackOverlay(): Fades in and out a black overlay over everything in the game, including the GUI. RenJS.pause() and RenJS.unpause(): Pauses and unpauses the game. RenJS.onInterpretActions: Map of functions called every time an action is interpreted, meaning on each step of the story. The only defined function at the start of the game is \u0026lsquo;updateStack\u0026rsquo; which controls the execution stack of the story, but you can add and remove functions that would then execute every time an action is interpreted.  Phaser As RenJS is built over Phaser, you can use any Phaser method to do whatever you want. Just be careful not to break everything!\n"
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/actions/effectandambient/",
	"title": "Effects and Ambients",
	"tags": [],
	"description": "",
	"content": " These actions allow you to show visual and sound effects. The difference between them is that effect is a nuclear action that ends after its execution, while ambient effects perdure over time. For example, an effect can be a thunder, while an ambient can be rain.\n- ambient ambient_id: param1: value1 param2: value2 - effect effect_id: param3: value3 param4: value4 - ambient CLEAR:  There are a few ambients and effects already coded, but these depend almost entirely on the kind of game you\u0026rsquo;re making. You can check the defined ambients and effects and tailor them to your needs. The effects and ambients usually use extra assets, either images, spritesheets, music and even code. All of this should be loaded in the extra section of the setup file. Check the Setup Guide for more info about this file.\nAmbients The ambients are defined inside the file RenJS/Ambient.js, inside the map called RenJS.ambient. A special ambient called CLEAR takes care of stopping any ambient set before. Other ambients are:\n BGS: Adds a looped background sound and nothing more. The sound id should be specified with the param sfx. RAIN: Starts a particle emitter and background sound for a rain mood. Additional assets:  image:  rain: A sprite of the raindrop.  music:  rain: A loopable audio.   SAKURA: Starts two particle emitters for a cherry blossoms falling ambient. Additional assets:  spritesheet:  sakura: A sprite of the cherry blossom, with 5 frames (17x17 px).   SNOW: Starts three particles emitters for a snowy mood. Additional assets:  spritesheet:  snowflakes: A sprite of the small snowflakes, with 5 frames (17x17 px). snowflakes_large: A sprite of the large snowflakes, with 5 frames (64x64 px).   DRUGS: A strange hallucinogenic effect. No additional assets required. For this effect to work the game mode should be WEBGL (set the game mode on the file RenJSBootstrap.js). BADTRIP: An extra effect to call after the DRUGS effect.  To make your own effect you can either modify the ones already coded, or make a completely different thing taking advantage of the visual effects and sprite manipulation capabilities of Phaser. The only thing you should remember is to call the funtion RenJS.resolve() when you finish. This function tells the automat that controls the story that it can continue with the next action. Another usefull thing is to add a function to call when the ambient is cleared. You can push a function to RenJS.ambient.clearFunctions and it will be called when the ambient CLEAR is set. This way you can destroy any sprite, stop any music, etc, that your ambient uses.\nEffects Very similar to ambients, the effects are defined inside the RenJS/Effects.js file. Some of the effects available are:\n SHAKE: Screen shake! SOUND: It takes a param with the name sfx and reproduces it. It\u0026rsquo;s the same as the play action. ROLLINGCREDITS: Sets a black screen and shows a list of text defined on the param text. It also takes the param endGame to directly end the game after the effect is over. The text list can have null lines that will be empty lines.  - effect ROLLINGCREDITS: endGame: true text: - Thank you for playing - Game Name - null - made by - lunafromthemoon - null - with - RenJS - null - whatever else you want to say   SHOWTITLE: Shows an image with a title and subtitle overimposed. The image should be loaded with the name title. The params title and subtitle will be shown in the middle of the image, with the first font defined in the Setup file. You can play with this effect and make up the titles however you like. THUNDER: Quickly shows and hides a thunder image, accompanied by a thunder sound effect. Needs extra parameters:  image:  thunder: The thunder image.  sfx:  thunderSFX: The thunder sound.   EXPLOSION: Shows an explosion animation, with an explosion sound. Needs extra parameters:  spritesheet:  explosion: The explosion animation (274x300px).  sfx:  explosionSound: The explosion sound.    "
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/actions/showandhide/transitions/",
	"title": "Transitions",
	"tags": [],
	"description": "",
	"content": " The transitions are used everytime we show, hide or change an image. This affects how that will be achieved. There are a few usual transitions ready to use with the game, but you can check the file RenJS/Transitions.js to see how to create your own transition.\nCUT The most common transition is CUT, that means the image will be simply shown (or hidden) instantly.\n- show deuzi: normal - show deuzi: angry WITH CUT  FADE The FADE transition will interpolate the alpha of the image, taking some time. To show an image it will go from alpha 0 to alpha 1, in a FADE IN. To hide and image it will do the contrary, going from alpha 1 to alpha 0 in a FADE OUT. To change on image for another, it will first do a FADE IN and then FADE OUT.\n- show deuzi: WITH FADE AT CENTER  FUSION If used to show or hide an image, FUSION will behave exactly like FADE, but when changing images, FUSION will do both the FADE IN and FADE OUT at the same time, and it will look aproximately like one image is fusing with the other one.\n- show room_dark_lamp_off: - show room_dark_lamp_on: WITH FUSION  FADETOBLACK, FADETOWHITE, FADETOCOLOR The whole screen will be covered by a color in a FADEIN, the changes to the image will be performed, and then a FADEOUT of the overlay will reveal the changes.\n- hide jair: WITH FADETOBLACK  MOVE Another important transition is MOVE, normally used for characters, will interpolate the current position of the image to the new one. For example, to show a character entering the screen from the right first you would show it in the position OUTRIGHT (outside of the screen, to the right side), and then show it at another position, using the MOVE transition.\n- show deuzi: WITH CUT AT OUTRIGHT - show deuzi: WITH MOVE AT CENTER  "
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://lunafromthemoon.github.io/RenJS/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]